# app/views/magic/index.html.effigy
 
class TransformIndexView < Effigy::Rails::View

  #metodo que sobrescreve Effigy::View::transform e aplica as regras ao template
  #TODO: limpar arquivos temporários  
  # transformar página após cada regra nova.
  def transform
       
    file = File.open(@page.file.path)
    temp_string = ""  
    file.each { |line| temp_string.concat(line.to_s) }
    file.close  
    
    File.delete("app/templates/transform/index.html")
    
    template = File.new("app/templates/transform/index.html","w")
    template.puts(temp_string)
    template.close
    
    
    base = @page.file.path.split(@page.user_id.to_s)[0] + @page.user_id.to_s
    file_name = @page.file.path.split(@page.user_id.to_s)[1]  # /index.html
    file_name_without_ext = file_name.split('.')[0]  # /index
    file_extension = file_name.split('.')[1]         # html


    File.delete(base + file_name_without_ext + '2.' + file_extension) if 
      File.exists?(base + file_name_without_ext + '2.' + file_extension)
          
    out = File.new(base + file_name_without_ext + '2.' + file_extension, "w+")
    
    @rules.each do |rule|                       # itera sobre as regras
      
      result = case rule.option
        # clona qualquer elemento selecionado... tá capenga  
        when 'clone' then 
          rule.css_selector.split(',').each { |one_selector|
            clone(normalize_rule(one_selector), rule.value, rule.text)
          }
        # substitui uma imagemS
        when 'image' then
          select(rule.css_selector).each do |node|
            puts rule.text 
            node.set_attribute("src", rule.text)
          end
        else # case
        
          if rule.text.empty? then              # elimina itens com texto em branco
            remove(rule.css_selector)
            
          elsif (rule.value != "") then
            select(rule.css_selector).each do |node|

              if node.name != "a" then
                node.replace("<a href=\"#{rule.value}\">#{rule.text}<\/a>")
              else
                node.set_attribute("href", rule.value)
                insert_content(node, rule.text)
              end
            end
            
 #           text(rule.css_selector, rule.text)
#            attr(rule.css_selector, 'href', rule.value)
          else
            text(rule.css_selector, rule.text)
            
          end
          
      end # case       
    end # .each
    
    out.puts(output)
    out.close
    
  end  # transform
  
   def yield_transform_and_output(document_or_fragment)
      @current_context = document_or_fragment
      yield if block_given?
      transform
      
      file_name = @page.file.path.split(@page.user_id.to_s)[1]  # /index.html
      file_name_without_ext = file_name.split('.')[0]  # /index
      file_extension = file_name.split('.')[1]         # html
      
      
      # retorno:
       "<script language=\"JavaScript\">
      <!--St
        var time = null
        function move() {
        window.location = '#{@adress}'
      }
      //-->
      </script>

      <body onload=\"timer=setTimeout('move()',1)\"></body>
      "
    end
    
  
  
  
  # método que duplica um nodo selecionado
  def clone(css_select, value, new_text)

    select(css_select).each do |node|
      
      attributes = ''
      node.attributes().each { |k,v|
        attributes.concat(k + "=\"" + v + "\"")
      }
      
      new_content = ''
      if Rule::STRUCTURAL_TAGS.include?(node.name) then
        new_node = node.clone
        
        # insere texto dado no novo duplicado
        if (!new_text.nil?) then
          insert_content(new_node, new_text)
        end
        
        node.after(new_node)
       
        # verifica se o nodo filho é do tipo a para inserir correspondente link 
        if (node.child.name != 'a') && (!value.nil?) then
           new_node.add_previous_sibling("\<a href=\"#{value}\"\>")

        else
          new_node.child.set_attribute("href", value)
        end
          
        
      elsif Rule::FORMATTING_TAGS.include?(node.name) then
        
      end
      
    end
  end


# Chamada recursiva para inserir conteúdo (texto) no nodo dado.
# O conteúdo deve ser inserido no último nodo filho.
  def insert_content(node, new_content)
  
    if node.children.empty? then
      node.content=(new_content)
    else
      insert_content(node.child, new_content)
    end
    node
    
  end


# retira vírgulas e espaços em branco ao final de um seletor CSS 
# (usado quando uma regra tem mais de um seletor separados com vírgulas)
  def normalize_rule(s)
    size = s.size
    if (s[size - 1].chr == ',') then
      s.chop!
    end
    s.strip!
    return s
  end
  
end

