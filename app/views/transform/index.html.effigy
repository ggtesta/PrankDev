# app/views/magic/index.html.effigy

class TransformIndexView < Effigy::Rails::View
  

  #metodo que sobrescreve Effigy::View::transform e aplica as regras ao template
  def transform

# TODO: setar o template do Effigy para @page.file.path
    
    file = File.open(@page.file.path)
    temp_string = ""
    file.each { |line| temp_string.concat(line.to_s) }
    file.close
    
    File.delete("app/templates/transform/index.html")
    
    template = File.new("app/templates/transform/index.html","w")
    template.puts(temp_string)
    template.close
    
#    @current_context = Nokogiri::HTML::Document.new(temp_string)
    
    @rules.each do |rule|                       # itera sobre as regras
      
      result = case rule.option
        # clona qualquer elemento selecionado... tá capenga  
        when 'clone' then 
          rule.css_selector.split(',').each { |one_selector|
            clone(normalize_rule(one_selector), rule.value, rule.text)
          }         
        else # case
        
          if rule.text.empty? then              # elimina itens com texto em branco
            remove(rule.css_selector)
          elsif (!rule.value.nil?) then
            text(rule.css_selector, rule.text)
#            attr(rule.css_selector, 'href', rule.value)
          else
            text(rule.css_selector, rule.text)
          end
      end # case       
    end # .each
    
    # melhorar criando 'file2.html'
    # exemplo: file.path:
    # /home/ggtesta/rails2.3/TCC/PrakDev/public/pages/1/index.html

    # /home/ggtesta/rails2.3/TCC/PrakDev/public/pages/1
    base = @page.file.path.split(@page.user_id.to_s)[0] + @page.user_id.to_s
    
    file_name = @page.file.path.split(@page.user_id.to_s)[1]  # /index.html
    file_name_without_ext = file_name.split('.')[0]  # /index
    file_extension = file_name.split('.')[1]         # html

    File.delete(base + file_name_without_ext + '2.' + file_extension) if 
      File.exists?(base + file_name_without_ext + '2.' + file_extension)
          
    out = File.new(base + file_name_without_ext + '2.' + file_extension, "w+")
    out.puts(output)
    out.close
    
#    redirect_to("pages/#{@page.user_id.to_s}#{file_name_without_ext}2.#{file_extension}")
    
  end  # transform
  
  
  def clone(css_select, value, new_text)
    
    select(css_select).each do |node|
      
      attributes = ''
      node.attributes().each { |k,v|
        attributes.concat(k + "=\"" + v + "\"")
      }
      
      new_content = ''
      if Rule::STRUCTURAL_TAGS.include?(node.name) then
        new_node = node.clone
        
        # insere texto dado no novo duplicado
        if (!new_text.nil?) then
          insert_content(new_node, new_text)
        end
        
        node.after(new_node)
       
        # verifica se o nodo filho é do tipo a para inserir correspondente link 
        if (node.child.name != 'a') && (!value.nil?) then
           new_node.add_previous_sibling("\<a href=\"#{value}\"\>")
       #    new_node.add_next_sibling("\<\/a\>")
        #  new_node.after("\<\a\>")
#          new_node.child.set_attribute('href', value)
          puts 'oi'
        end
        

        
      
      elsif Rule::FORMATTING_TAGS.include?(node.name) then
      end
      
    end
  end

# Chamada recursiva para inserir conteúdo (texto) no nodo dado.
# O conteúdo deve ser inserido no último nodo filho.
  def insert_content(node, new_content)
  
    if node.children.empty? then
      node.content=(new_content)
    else
      insert_content(node.child, new_content)
    end
    node
    
  end


# retira vírgulas e espaços em branco ao final de um seletor CSS 
# (usado quando uma regra tem mais de um seletor separados com vírgulas)
  def normalize_rule(s)
    size = s.size
    if (s[size - 1].chr == ',') then
      s.chop!
    end
    s.strip!
    return s
  end
  
end

